# JavaScript 闭包

最近换了个项目，开始写一些前端代码，对于我这种前端小白来说，也是一头雾水的开始。期间看到一些不是很懂的东西，想着抽时间总结出来，加深记忆。当然，好久不写东西了，最近开始写的一个主要原因是嫁给了一个无比热爱写代码的老公，天天像监工一样逼我写博客（~~所以千万不要和同行结婚，哈哈哈哈，我肯定会被打死~~）。

## 什么是闭包

看了很多解释，大概说的都是如下：

闭包（Closure）是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。

然而每个字都认识，就是不知道在说什么。直到看到了知乎上一个人的解答仿佛恍然大悟。他说：

**函数** 和 **函数内部能访问到的变量**（也叫环境）的总和，就是一个闭包。

比如下面代码：
 
``` js
function init() {
    var name = "San Pang"; // name 是一个被 init 创建的局部变量
    function displayName() { // displayName() 是内部函数,一个闭包
        alert(name); // 使用了父函数中声明的变量
    }

    displayName();
}
```

上面代码中，有一个局部变量 `name`，一个函数 `displayName`, 函数`displayName`能访问到局部变量 `name`，完全符合上面的定义，这就是一个闭包。

是不是很简单？

简直简单的让人难以置信！我也很疑惑啊，不是说闭包会 `return` 一个函数的嘛？比如下面代码：

``` js
function makeFunc() {
    var name = "San Pang"; // name 是一个被 init 创建的局部变量
    function displayName() { // displayName() 是内部函数,一个闭包
        alert(name); // 使用了父函数中声明的变量
    }

    return displayName;
}

var myFunc = makeFunc();
myFunc();
```

仔细按照上面的定义分析一下，这里面确实有闭包，局部变量 `name` 和函数`displayName` 就组成了一个闭包。

#### 为什么要函数套函数呢？

是因为需要**局部变量**，所以才把 `name` 放在一个函数里，如果不把 `name` 放在一个函数里，它就是一个全局变量了，达不到使用闭包的目的——隐藏变量。在我们的例子中，`myFunc` 是执行 `makeFunc` 时创建的 `displayName` 函数实例的引用，而 `displayName` 实例仍可访问其词法作用域中的变量，即可以访问到 `name` 。由此，当 `myFunc` 被调用时，`name` 仍可被访问，其值 `Mozilla` 就被传递到 `alert`中。

所以函数套函数只是为了造出一个局部变量，跟闭包无关。

#### 为什么要 `return` 函数呢？

答案很简单，为了使用这个闭包。如果不 `return` 函数 `displayName`, 外面就访问不到里面的函数。

所以 `return` 函数只是为了让函数能被使用，也跟闭包无关。

## 闭包的用处

说了这么多，到底什么时候会用到闭包呢？

闭包常常用来**间接访问变量**。换句话说，**隐藏变量**。

假设我们在做一个麻将游戏，在写其中关于还剩多少钱的代码。

如果不用闭包，你可以直接用一个全局变量：

``` js
window.money = 400 // 还有四百块
```

这样看起来很不安全。万一不小心把这个值改了怎么办。所以我们不能让别人**直接访问**这个变量。怎么办呢？

只能用局部变量喽。

但是用局部变量别人又访问不到，怎么办呢？

那就暴露一个访问器（函数），让别人可以**间接访问**。

代码如下：

``` js
function calMoney() {
    var money = 400;

    return {
        win: function () {
            money += 10;
            console.log(money);
        },
        lose: function () {
            money -= 10;
            console.log(money);
        }
    }
}

var cal = calMoney();

cal.win(); //410
cal.lose(); // 400
cal.lose(); //390
```

这样就可以通过调用 `cal.win()` 或 `cal.lose()`来加或者减钱了。

在上面的例子了，局部变量 `money` 和使用它的函数 `win` 和 `lose` 组成了两个闭包。