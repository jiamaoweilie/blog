# Hi，函数式编程

## 函数式编程的起源
20世纪30年代，在经济大萧条的背景下，新建成的哥特式办公楼给普林斯顿大学带来一种天堂般的安全感。来自世界各地的逻辑学者应邀来到普林斯顿组建一个新的学部。正当大部分美国人还在为找不到一片面包做晚餐而发愁的时候，在普林斯顿却是这样一番景象：高高的天花板和木雕包覆的墙，每天品茶论道，漫步丛林。 一个名叫[阿隆佐·邱奇(Alonzo Church)](https://zh.wikipedia.org/zh/%E9%98%BF%E9%9A%86%E4%BD%90%C2%B7%E9%82%B1%E5%A5%87)的年轻数学家就过着这样优越的生活。阿隆佐本科毕业于普林斯顿后被留在研究院。他觉得这样的生活完全没有必要，于是他鲜少出现在那些数学茶会中也不喜欢到树林里散心。阿隆佐更喜欢独处：自己一个人的时候他的工作效率更高。尽管如此他还是和普林斯顿学者保持着联系，这些人当中有[艾伦·图灵](https://zh.wikipedia.org/zh/%E8%89%BE%E4%BC%A6%C2%B7%E5%9B%BE%E7%81%B5)、[约翰·冯·诺伊曼](https://zh.wikipedia.org/zh/%E7%BA%A6%E7%BF%B0%C2%B7%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC)、[库尔特·哥德尔](https://zh.wikipedia.org/zh-hant/%E5%BA%93%E5%B0%94%E7%89%B9%C2%B7%E5%93%A5%E5%BE%B7%E5%B0%94)。

这四个人都对形式系统感兴趣。相对于现实世界，他们更关心如何解决抽象的数学问题。而他们的问题都有一个共同点：都在尝试解答关于计算的问题。诸如：如果有一台拥有无穷计算能力的超级机器，可以用来解决什么问题？它可以自动的解决这些问题吗？是不是还是有些问题解决不了，如果有的话，是为什么？如果这样的机器采用不同的设计，它们的计算能力相同吗？

在与这些人的合作下，阿隆佐设计了一个名为lambda演算的形式系统。这个系统实质上是为其中一个超级机器设计的编程语言。在这种语言里面，函数的参数是函数，返回值也是函数。这种函数用希腊字母lambda（λ）表示，这种系统因此得名。有了这种形式系统，阿隆佐终于可以分析前面的那些问题并且能够给出答案了。
除了阿隆佐·邱奇，艾伦·图灵也在进行类似的研究。他设计了一种完全不同的系统（后来被称为图灵机），并用这种系统得出了和阿隆佐相似的答案。到了后来人们证明了图灵机和lambda演算的能力是一样的。

![lambda](/images/img_for_fp/lambda.jpg)

后来，二战爆发，整个世界陷于火海之中。那时的美军空前的大量使用炮兵。为了提高轰炸的精度，军方聘请了大批数学家夜以继日的求解各种差分方程用于计算各种火炮发射数据表。后来他们发现单纯手工计算这些方程太耗时了，为了解决这个问题，各种各样的计算设备应运而生。IBM制造的Mark一号就是用来计算这些发射数据表的第一台机器。Mark一号重5吨，由75万个零部件构成，每一秒可以完成3次运算。

二战后，人们为提高计算能力而做出的努力并没有停止。1949年第一台电子离散变量自动计算机诞生并取得了巨大的成功。它是冯·诺伊曼设计架构的第一个实例，也是一台现实世界中实现的图灵机。相比他的这些同事，那个时候阿隆佐的运气就没那么好了。
	
到了50年代末，一个叫John McCarthy的MIT教授对阿隆佐的成果产生了兴趣。1958年他发明了一种列表处理语言（Lisp），这种语言是一种阿隆佐lambda演算在现实世界的实现，而且它能在冯·诺伊曼计算机上运行！很多计算机科学家都认识到了Lisp强大的能力。1973年在MIT人工智能实验室的一些程序员研发出一种机器，并把它叫做Lisp机。于是阿隆佐的lambda演算也有自己的硬件实现了。

这些就是科学家们对函数式编程早期的探索。

## 什么是函数式编程

[函数式编程（functional programming）](https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B8%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80)是阿隆佐的思想在现实世界中的实现。与面向对象一样，函数式编程是一种编程风格，其主要思想是把运算过程写成一些列嵌套的函数调用。函数是函数式编程的基础元素，可以完成几乎所有的操作，哪怕是最简单的操作，也要用函数来完成。

我们通常理解的变量在函数式编程中也被函数代替了。在函数式编程中变量仅仅代表某个表达式，所以我们这里所说的‘变量’是不能被修改的。所有的变量只能被附一次初值。在Java中就意味着每一个变量都将被声明为final，在函数式编程中，没有非final的变量。

我们先用一个最简单的例子来说明一下什么是函数式编程。

先看一个非函数式的例子，实现一个数组首字母大写的方法，我们一般会如下写：

``` js
const arr = ['apple', 'pen', 'apple-pen'];
for (const i in arr) {
    const c = arr[i][0];
    arr[i] = c.toUpperCase() + arr[i].slice(1);
}

console.log(arr);
```

当情况变得更加复杂时，这种表达式的写法会遇到几个问题：

* 表意不明显，逐渐变得难以维护
* 复用性差，会产生更多的代码量
* 会产生很多中间变量

那么，函数式的应该怎么写呢？

``` js
function upperFirst(word) {
    return word[0].toUpperCase() + word.slice(1);
}

function wordToUpperCase(arr) {
    return arr.map(upperFirst);
}

console.log(wordToUpperCase(['apple', 'pen', 'apple-pen']));
```

或者直接：

``` js
console.log(arr.map(word => word[0].toUpperCase() + word.slice(1)));	
```

观察上面的例子可以看出，函数式的写法利用了函数封装性将功能做拆解，并封装为不同的函数，而再利用组合的调用达到目的。

与命令式相比，这样做的好处在哪？主要有以下几点：

* 语义更加清晰
* 可复用性更高
* 可维护性更好
* 作用域局限，副作用少

## 函数式编程的特点

### 函数是一等公民

所谓“第一等公民”，是指函数和其他数据类型拥有平等的地位，可以赋值给变量，也可以作为参数传入另一个函数，或者作为别的函数的返回值。

例如下面的代码中，我们要找出所有的偶数，函数filter的变量就是传入另一个函数：

```	js
var odd = [1, 2, 3, 4, 5].filter(function (x) {
    return x % 2 == 0
})
```

### 纯函数

纯函数在这里指函数内外间是“无”关联的，即相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用。其主要特点有一下两个：

* 没有副作用（side effect）
* 引用透明

函数副作用是指当调用函数时，除了返回函数值之外，还对该函数外部的状态产生了改变。函数副作用会给程序设计带来不必要的麻烦，给程序带来潜在的错误，并且降低程序的可读性。

函数式编程强调没有"副作用"，意味着函数要保持独立，所有功能就是返回一个新的值，没有其他行为，尤其是不得修改外部变量的值。

一个比较极端的有副作用的例子：

``` js
var count = 1;

var increase = function () {
    count++;
}

console.log(count); //1

increase();

console.log(count); //2
```

在执行完函数时，变量`count`的值发生了改变。

没有副作用的写法可以为；

``` js
var count = 1;

var increase = function () {
    return count + 1;
}

console.log(count); //1

increase();

console.log(count); //1
```

除此之外，函数的副作用可能包含，但不限于：

* 更改文件系统
* 往数据库插入记录
* 发送一个 http 请求
* 可变数据
* 打印/log
* 获取用户输入
* DOM 查询
* 访问系统状态

**引用透明**，指的是函数的运行不依赖于外部变量或"状态"，只依赖于输入的参数，任何时候只要参数相同，引用函数所得到的返回值总是相同的。换句话说，引用透明要求函数不论进行了任何操作都可以用它的返回值代替。

其他类型的语言，函数的返回值往往与系统状态有关，不同的状态之下，返回值是不一样的。这就叫"引用不透明"，很不利于观察和理解程序的行为。

### 不可变数据

上一点已经提到，函数式编程只是返回新的值，不修改系统变量。因此，不修改变量，也是它的一个重要特点。

在其他类型的语言中，变量往往用来保存"状态"（state）。不修改变量，意味着状态不能保存在变量中。函数式编程使用参数保存状态，最好的例子就是递归。下面的代码是一个将字符串逆序排列的函数，它演示了不同的参数如何决定了运算所处的"状态"。

``` js
function reverse(string) {
    if (string.length == 0) {
        return string;
    } else {
        return reverse(string.substring(1, string.length)) + string.substring(0, 1);
    }
}
```

之所以使用这种不变值，除了更好的函数式编程外，还能够维持线程安全可靠，落地在业务中，实际上也能让代码更加清晰。

设想，如果你定义了一个变量A，A在其他地方被其他人修改了，这样是不方便定位A的当前值的。

### 只用"表达式"，不用"语句"

"表达式"（expression）是一个单纯的运算过程，总是有返回值；"语句"（statement）是执行某种操作，没有返回值。函数式编程要求，只使用表达式，不使用语句。也就是说，每一步都是单纯的运算，而且都有返回值。

原因是函数式编程的开发动机，一开始就是为了处理运算（computation），不考虑系统的读写（I/O）。"语句"属于对系统的读写操作，所以就被排斥在外。

当然，实际应用中，不做I/O是不可能的。因此，编程过程中，函数式编程只要求把I/O限制到最小，不要有不必要的读写行为，保持计算过程的单纯性。

## 常见的函数式编程模型

### 闭包（Closure）

可以保留局部变量不被释放的代码块，被称为一个闭包。

我们通过一个例子来看一下闭包带来的好处。先创建一个闭包

``` js
function makeCounter() {
    var k = 0;

    return function () {
        return ++k;
    };
}

const counter = makeCounter();

console.log(counter()); // 1
console.log(counter()); // 2
```

makeCounter 这个函数的代码块，在返回的函数中，对局部变量 k ，进行了引用，导致局部变量无法在函数执行结束后，被系统回收掉，从而产生了闭包。而这个闭包的作用就是，“保留”住了局部变量，使内层函数调用时，可以重复使用该变量；而不同于全局变量，该变量只能在函数内部被引用。

换句话说，闭包其实就是创造出了一些函数私有的 ”持久化变量“。

所以从这个例子，我们可以总结出，闭包的创造条件是：

* 存在内、外两层函数
* 内层函数对外层函数的局部变量进行了引用

#### 闭包的用途

闭包的主要用途就是可以定义一些作用域局限的持久化变量，这些变量可以用来做缓存或者计算的中间量等等。

``` js
const cache = (function () {
    const store = {};

    return {
        get(key) {
            return store[key];
        },
        set(key, val) {
            store[key] = val;
        }
    }
}());

cache.set('a', 1);
cache.get('a'); //1
```

上面例子是一个简单的缓存工具的实现，匿名函数创造了一个闭包，使得`store`对象 ，一直可以被引用，不会被回收。

#### 闭包的弊端

持久化变量不会被正常释放，持续占用内存空间，很容易造成内存浪费，所以一般需要一些额外手动的清理机制。

### 高阶函数

在函数式编程中，我们称接受或者返回一个函数的函数为高阶函数。

高阶函数，听上去好像是个很高冷的数学词汇，但是其实在工作中我们经常用到它，只是原来不知道他们的名字而已。我们经常可以在JavaScript中见到许多原生的高阶函数，例如 `Array.map`，`Array.reduce`，`Array.filter`等等。我们在上文的示例中就多次用到`map`函数，它是对集合而言的，即把集合的每一项都做相同的变换，产生一个新的集合。

### 柯里化

柯里化的概念很简单：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。

``` js
var add = function (x) {
    return function (y) {
        return x + y;
    };
};

var increment = add(1);
var addTen = add(10);

console.log(increment(2)); // 3

console.log(addTen(2));// 12
```

这个例子中的`increment`，和`addTen`就是通过一部分参数来调用函数`add`。

对于柯里化这个名词，我们可能不常听到这个名词，但是用过`undescore`或`lodash`的人都见过他。

### 组合

组合，顾名思义，将多个函数的能力合并，创造一个新的函数。

它的代码实现大概如下：

``` js
var compose = function (f, g) {
    return function (x) {
        return f(g(x));
    };
};
```

组合看起来像是在饲养函数。你就是饲养员，选择两个有特点又遭你喜欢的函数，让它们结合，产下一个崭新的函数。组合的用法如下：

``` js
var toUpperCase = function (x) {
    return x.toUpperCase();
};

var exclaim = function (x) {
    return x + '!';
};
var shout = compose(exclaim, toUpperCase);

console.log(shout("this is apple, this is pen, apple-pen!"));
//THIS IS APPLE, THIS IS PEN, APPLE-PEN!!
```

本文简单介绍了函数式编程的基本概念、特点，和一些简单的模型，但是由于是刚开始学习，很多方面也不是很懂，会在以后继续学习和补充。

这里有一些我学习时的参考资料：

* [JS函数式编程指南](https://www.gitbook.com/book/llh911001/mostly-adequate-guide-chinese/details)
* [Functional Programming For The Rest of Us](http://www.defmacro.org/ramblings/fp.html)
* [函数式编程入门教程](http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html)
* [Functor、Applicative 和 Monad](http://blog.leichunfeng.com/blog/2015/11/08/functor-applicative-and-monad/)


